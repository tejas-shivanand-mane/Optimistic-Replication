========================================================
PODC '24 Paper #621 
Convergence and Integrity for Optimistically Replicated Objects

Review #621A		2	3
Review #621B		2	3
Review #621C		3	4

========================================================
Review A:

I generally found the protocols to be sensible. However, I couldn't determine what is novel in the paper. I believe the protocol themselves are new (in the sense that the same protocols were not published before), but I couldn't see any new general-purpose techniques, insights, or principles used to design those protocols. As such, the main contribution is purely protocol engineering. I believe there's more to that in the protocols, but the authors haven't distilled it yet.

The protocols aren't practical, because they require the precomputation and topological sort of a potentially infinite graph (e.g., in the common case where operations have parameters, such that the number of distinct calls is infinite).

The paper isn't explicit about the system model, which is a sin in PODC/DISC. From what I could gather, the protocol requires either a synchronous system (with known bounds on processing and network delays) or a partially synchroous system. The failure model is also not explicit, but the paper seems to address crash failures, at least in two of the three protocols. I also don't understand the network assumptions.

Finally, the paper is a nightmare to read, because the presentation introduces a lot of heavy notation just to describe the algorithms. As a result, just understanding what the algorithms do (let alone why they are correct) takes several hours of reading.

Because of the above issues, I believe publishing this paper now would be premature. However, I believe the paper has the potential to be very interesting.

Specific comments:

- Provide more motivation and examples where it's important to have the integrity property, which is a key part of your contribution.

- Page 2, "We call the process where the call c is requested and first executed...": you need to provide a more context about the protocol before you define this. You consider a protocol where a client first contacts a single process for execution, and then that process is responsible for propagating the call to others (as opposed to the client doing that).

- But then, what do you do if that single process fails?

- Page 2, "c was executed at home(c') before c' was submitted to home(c')": what does it mean to be submitted? Who submits what? Again, you need to provide more context of the protocol before defining things.

- Page 2, typo: "is always forwards"

- Page 2, "if \forall i \exists j": Ouch. You don't need a second-order predicate here, because you can separate these as \forall i: v_i <= v'_i and \exists j: v_j < v'_j.

- Page 2, "In which case, c happens-before c'": grammar error, this isn't a proper sentence.

- Page 2, typo: "should ordered"

- Definition 3: why do you define things in term of pre-state instead of post-state? This way, if you have a finite execution, the last call won't be checked by integrity, which seems wrong.

- Page 5, "where Delta is the upper bound on message delay": that's not enough. You also need to upper bound processing time. This problem arises because you weren't precise about your system model.

- Section 4: what form of partial synchrony do you consider?

========================================================
Review B:

W1) The paper is misleadingly pitched

W2) Unclear application of the protocols in practice

W3) No strong theoretical results

W4) No proper comparison to related work

W5) Presentation can be improved by giving examples of concrete applications

#### Detailed comments for authors

* Your claim that the proposed optimistic replication protocols preserve convergence and integrity while avoiding synchronization in the critical path is misleading. It is true that all protocols execute operations locally and return to the client immediately. Nevertheless, operations may be reordered or even aborted in the case of a cyclic conflict graph after returning to the client. Thus, one could consider that effectively, an operation is only completed after processes synchronize, i.e., synchronization is in the critical path.

* The protocols may have little relevance in practice: it seems that even the simplest application will result in a cyclic conflict graph. This significantly restricts the class of applications that can run on top of the proposed protocols, as it requires applications to tolerate not only reordering but also aborts after the local process has returned. By simplest application I mean an application as the one sketched in the introduction: an e-commerce application where all operations converge by default (assume that all objects are CRDTs), and only place-order operations on the same item conflict, i.e., can lead to an integrity violation. 

* While technically sound, the paper does not include strong theoretical results such as impossibility results or lower bounds. It would be interesting to know what’s possible and what’s not. This is more relevant given the argued little relevance of the protocols in practice (see the above point).

* The comparison in the introduction to the related work is insufficient; it should have its own section. The authors should consider extending the related work to include deterministic databases such as Calvin (SIGMOD’ 12) and the literature on speculative replication. Although those works are mostly concerned with transactions, there is a clear common ground between those approaches and the protocols proposed in the paper.

#### Suggestions to improve the presentation:

* Motivation could be improved by giving examples of real applications that can tolerate/use speculation.

* The paper could discuss more clearly which metrics the proposed protocols aim to optimize: minimize remote aborts while maximizing local operation availability, instead of leaving it up to the reader’s interpretation.

* The paper explains how to construct the conflict graph but does not explain intuitively why it is constructed that way.

* The observation made in Section 3 between Theorem 2 and 3 is key to understanding intuitively what the conflict graph represents and how protocols can leverage it to reason about integrity. It is currently somewhat hidden. I suggest moving it to the end of Section 2 and explaining intuitively how the upcoming protocols exploit this (and possibly other properties) of the conflict graph in their design.

* Use simplified variants of real applications throughout the paper to construct concrete conflict graphs and help the reader understand which class of applications have an acyclic or cyclic conflict graph.

* Add a table with the notation introduced in Section 2, I have found myself revisiting that section multiple times when reading the paper.

#### Other comments

* At the beginning of Section 3, the paper states that processes use uniform reliable broadcast to propagate calls. I would move this to the beginning of Section 2.
* Typo in the first sentence of page 3: “the call is is…”
* Typo in Static Conflicts paragraph in Section 2: “Next, for each undirected edge (m,m’) \in G_s”. It should be G^M_s.
* Typo in the first bullet of the last remark in Section 3: if homec < homec’
* Typo in Stable Local Call Handler paragraph in Section 4: \mu(c’) <=_T c
* Typo last sentence Section 5: "Thus, processes are not blocked when a cycle arises. are not clocked."

========================================================
Review C:

- The paper builds on the theory of well-coordination in [23] and the relationship with previous systems such as Hamsaz is not clear. Hamsaz uses synchronization to deal with conflicts while the algorithms in this paper seem to be based on the same ideas, but aborting operations instead of synchronizing replicas to decide on an order. The technical challenges that needed to be addressed in comparison to Hamsaz are not very clear.

- From a theoretical point of view, the algorithms ensure availability. However, they may decide to abort operations. The unavailability is pushed in some sense to the level of the application that needs to retry an aborted operation.

- Since the algorithms trade synchronization for the possibility of aborting operations, some empirical evaluation is necessary to show their practical benefits.

========================================================


